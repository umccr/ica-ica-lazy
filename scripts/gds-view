#!/usr/bin/env bash

: '
Uses docker links to view the gds file through its presigned url
'

set -euo pipefail

### GLOBALS
SECONDS_PER_WEEK="604800"

## Internal functions
echo_stderr(){
  echo "$@" 1>&2
}

get_docker_binary(){
  if type docker 1>/dev/null 2>&1; then
    echo "docker"
  else
    echo "podman"
  fi
}

print_help(){
  echo "
        Usage: gds-view ( --gds-path gds://volume-name/path-to-file ) [ --to-stdout | --browser ]

        Options:
            -g / --gds-path: Path to gds file
            -s / --to-stdout: Print file to stdout
            -b / --browser: Open url in browser

        Requirements:
          * docker | podman
          * jq
          * python3
          * wget

        Environment:
          * ICA_BASE_URL
          * ICA_ACCESS_TOKEN
          * BROWSER (only if --browser is set) should point to absolute path to the FireFox executable

        The program runs the links binary through docker to
        the gds path via a presigned url.  This can be used on text files and even gzipped files!
        Use --to-stdout to print the file to stdout, or --browser to open up the file in your browser.
        "
}

# Inputs
gds_path=""
access_token="${ICA_ACCESS_TOKEN-}"
base_url="${ICA_BASE_URL-}"
to_stdout="false"
browser="false"

while [ $# -gt 0 ]; do
    case "$1" in
        -g|--gds-path)
            gds_path="$2"
            shift 1
        ;;
        -s|--to-stdout)
            to_stdout="true"
        ;;
        -b|--browser)
            browser="true"
        ;;
        -h|--help)
            print_help
            exit 1
    esac
    shift
done

###########
# FUNCTIONS
###########

# Get volume

get_sed_command(){
  if [[ "${OSTYPE}" == "darwin"* ]]; then
    echo "gsed"
  else
    echo "sed"
  fi
}

get_epoch_expiry(){
  : '
  Get the epoch value of the expiry date of the tokens
  '
  local access_token="$1"
  echo "${access_token}" | \
    "$(get_sed_command)" -r 's/^(\S+)\.(\S+)\.(\S+)$/\2/' | \
    ( base64 -d 2>/dev/null || true ) | \
    jq -r '.exp'

}

get_seconds_to_expiry(){
  : '
  Get seconds to expiry based on epoch time
  '
  local expiry_epoch="$1"
  bc <<< "${expiry_epoch} - $(date +%s)"
}

warn_time_to_expiry(){
  : '
  Convert the epoch time to expiry to a readable date format
  '
  local expiry_in_seconds="$1"

  python3 -c "from datetime import timedelta; from sys import stderr; \
              time_to_expiry=timedelta(seconds=${expiry_in_seconds}); \
              d = {'days': time_to_expiry.days}; \
              d['hours'], rem = divmod(time_to_expiry.seconds, 3600); \
              d['minutes'], d['seconds'] = divmod(rem, 60); \
              print('Expired') if ${expiry_in_seconds} < 0 \
              else print(f\"Warning: Your ica access token will end in {d['days']} days, {d['hours']} hours, {d['minutes']} minutes, {d['seconds']} seconds\", file=stderr)"
}

## Checkers
check_token_expiry(){
  : '
  Return the expiry in printable format
  '
  # Inputs
  local access_token="$1"

  # local vars
  local epoch_expiry
  local seconds_to_expiry

  # Get the JWT token expiry time
  epoch_expiry="$(get_epoch_expiry "${access_token}")"

  # Compare expiry to current time
  seconds_to_expiry="$(get_seconds_to_expiry "${epoch_expiry}")"

  # Check token expiry
  if [[ "${seconds_to_expiry}" -le 0 ]]; then
    # Token has expired
    echo_stderr "Error - Your access token has expired! Please refresh with 'ica-add-access-token'"
    exit 1
  elif [[ "${seconds_to_expiry}" -le "${SECONDS_PER_WEEK}" ]]; then
    # Warn user token expires in less than a week
    echo_stderr "$(warn_time_to_expiry "${seconds_to_expiry}")"
  fi
}

get_volume_from_gds_path(){
  : '
  Assumes urllib is available on python3
  '
  local gds_path="$1"
  # Returns the netloc attribute of the gds_path
  python3 -c "from urllib.parse import urlparse; print(urlparse(\"${gds_path}\").netloc)"
}

# Get file path
get_file_path_from_gds_path(){
  : '
  Assumes urllib is available on python3
  '
  local gds_path="$1"
  # Returns the path attribute of gds_path input
  python3 -c "from urllib.parse import urlparse; print(urlparse(\"${gds_path}\").path)"
}

get_file_id(){
  : '
  Use files list on the file and collect the file id from the single item
  '
  local volume_name="$1"
  local file_path="$2"
  local access_token="$3"
  local base_url="$4"
  # Pipe curl output into jq to collect ID and return
  curl \
    --silent \
    --request GET \
    --header "Authorization: Bearer ${access_token}" \
    "${base_url}/v1/files?volume.name=${volume_name}&path=${file_path}" | \
  jq \
    --raw-output \
    '.items[] | .id'
}

get_presigned_url_from_file_id(){
  : '
  Use files list on the file and collect the file id from the single item
  '
  local file_id="$1"
  local access_token="$2"
  local base_url="$3"
  curl \
    --silent \
    --request GET \
    --header "Authorization: Bearer ${access_token}" \
    "${base_url}/v1/files/${file_id}" | \
  jq \
    --raw-output \
    '.presignedUrl'
}

run_links(){
  : '
  Runs the links container
  '
  local presigned_url="$1"
  # Send through to links
  "$(get_docker_binary)" run \
    --rm \
    -it \
    --entrypoint "links" \
    quay.io/umccr/alpine-links:2.21 \
    	"${presigned_url}"
}

# Checks, ensure access_token is set
if [[ -z "${access_token}" ]]; then
  echo "Error: Need to set ICA_ACCESS_TOKEN env var" 1>&2
  echo "Error: Please first run ica-context-switcher" 1>&2
  print_help
  exit 1
elif [[ -z "${base_url}" ]]; then
  echo_stderr "Error: Please set the env var ICA_BASE_URL"
  print_help
  exit 1
else
  # Check token expiry
  check_token_expiry "${access_token}"
fi



# Get volume name / get file path from gds path
volume_name="$(get_volume_from_gds_path "${gds_path}")"
file_path="$(get_file_path_from_gds_path "${gds_path}")"

# Collect file id
file_id="$(get_file_id "${volume_name}" "${file_path}" "${access_token}" "${base_url}")"

# Collect presigned url
presigned_url="$(get_presigned_url_from_file_id "${file_id}" "${access_token}" "${base_url}")"

# Present file
if [[ "${to_stdout}" == "true" ]]; then
  # Print to stdout
  wget --output-document - "${presigned_url}" 2>/dev/null
  # Check if we're in a pipe or not
  if [ -t 1 ]; then
    # If we're running in terminal, we want the user to have their console back
    echo ""
  fi
elif [[ "${browser}" == "true" ]]; then
  if [[ -z "${BROWSER-}" ]]; then
    echo_stderr "Error: --browser selected but 'BROWSER' env var is not set"
    exit 1
  fi
  "${BROWSER}" "${presigned_url}"
else
  # Run links through docker
  run_links "${presigned_url}"
fi