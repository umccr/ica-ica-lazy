#!/usr/bin/env bash

: '
Given an input json checks the following

input is present
name is present
check if engineParameters is present - encourage user to use if not present

Much credit to this snippet for flattening arrays in jq
https://gist.github.com/olih/f7437fb6962fb3ee9fe95bda8d2c8fa4#gistcomment-3045352
'

echo_stderr(){
  echo "${@}" 1>&2
}

flatten_inputs(){
  : '
  Get the flattened inputs object as a . based flattened output
  '
  jq --raw-output '[
         . as $in |
         (paths(scalars), paths((. | length == 0)?)) |
         join(".") as $key |
         $key + "=" + ($in | getpath($key | split(".") | map((. | tonumber)? // .)) | tostring)
       ] |
       sort |
       .[]' <<< "$1"
}

get_sed_command(){
  if [[ "${OSTYPE}" == "darwin"* ]]; then
    echo "gsed"
  else
    echo "sed"
  fi
}

# Get volume from gds path
get_volume_from_gds_path() {
  : '
  Assumes urllib is available on python3
  '
  local gds_path="$1"

  # Returns the netloc attribute of the gds_path
  python3 -c "from urllib.parse import urlparse; print(urlparse(\"${gds_path}\").netloc)"
}

# Get folder path
get_folder_path_from_gds_path() {
  : '
  Assumes urllib is available on python3
  '
  local gds_path="$1"

  # Returns the path attribute of gds_path input
  python3 -c "from urllib.parse import urlparse; from pathlib import Path; print(str(Path(urlparse(\"${gds_path}\").path)).rstrip(\"/\") + \"/\")"
}

get_file_path_from_gds_path(){
  : '
  Assumes urllib is available on python3
  '
  local gds_path="$1"
  # Returns the path attribute of gds_path input
  python3 -c "from urllib.parse import urlparse; print(urlparse(\"${gds_path}\").path)"
}


check_folder_exists(){
  : '
  Check that the input folder exists
  folder checking is a little more complex than file checking, need to run an ica folders list on the folder itself and
  then get the folder id
  # TODO - test this bit
  '
  local input_key_stripped="$1"
  local input_value="$2"
  local ica_access_token="$3"
  local ica_base_url="$4"
  local volume_name
  local folder_path

  volume_name="$(get_volume_from_gds_path "${input_value}")"
  folder_path="$(get_folder_path_from_gds_path "${input_value}")"

  # Return the folder id
  folder_id="$(curl \
                 --silent \
                 --request GET \
                 --header "Authorization: Bearer ${ica_access_token}" \
                 "${ica_base_url}/v1/folders?volume.name=${volume_name}&path=${folder_path}" |
               jq \
                 --raw-output \
                 '.items[] | .id')"

  if [[ -z "${folder_id}" || "${folder_id}" == "null" ]]; then
    echo_stderr "Could not get folder id for \"${input_value}\""
    return 1
  fi
}

check_file_exists(){
  : '
  Check that the input file exists
  '
  local input_key_stripped="$1"
  local input_value="$2"
  local ica_access_token="$3"
  local ica_base_url="$4"
  local volume_name
  local file_path

  volume_name="$(get_volume_from_gds_path "${input_value}")"
  file_path="$(get_file_path_from_gds_path "${input_value}")"

  # Return the folder id
  file_id="$(curl \
                 --silent \
                 --request GET \
                 --header "Authorization: Bearer ${ica_access_token}" \
                 "${ica_base_url}/v1/files?volume.name=${volume_name}&path=${file_path}" |
               jq \
                 --raw-output \
                 '.items[] | .id')"

  if [[ -z "${file_id}" || "${file_id}" == "null" ]]; then
    echo_stderr "Could not get file id for \"${input_value}\""
    return 1
  fi
}

get_class_type(){
  : '
  Get the class type, iterate over flattened inputs, get value of "input_key_stripped"."class"
  '
  local input_key_stripped="$1"
  local flattened_inputs="$2"

  while read -r input_key_val_pair; do
     # Split into keys and values
     input_key="$(cut -d'=' -f1 <<< "${input_key_val_pair}")"
     input_value="$(cut -d'=' -f2 <<< "${input_key_val_pair}")"

     # Get the input value
     if [[ "${input_key}" == "${input_key_stripped}.class" ]]; then
       if [[ "${input_value,,}" == "file"  || "${input_value,,}" == "directory" ]]; then
         # ,, syntax means .tolower()
         echo "gds_${input_value,,}"
       fi
     fi
  done <<< "${flattened_inputs}"
}

strip_last_period(){
  : '
  Equivalent of rsplit(".", 1)[0] in python
  '
  local input_key="$1"
  # This is gross, I am sorry
  # sed is greedy, so the first (.*) will match as much as it can
  "$(get_sed_command)" -r "s/(.*)\.(.*)/\1/" <<< "${input_key}"
}

check_name_value(){
  : '
  Check name value
  '
  local name_value="$1"

  if [[ "${name_value}" =~ [^a-zA-Z0-9_-] ]]; then
    echo_stderr "Name must be a-zA-Z0-9_-, please don't put in spaces or symbols"
    return 1
  fi
}

check_input_value(){
  : '
  Check input value
  '
  local inputs="$1"

  # Check if inputs are null
  if [[ -z "${inputs}" || "${inputs}" == "null" ]]; then
    echo_stderr "Could not find any inputs, under 'input'. Are you sure you want this?"
    return 0
  fi

  flattened_inputs="$(flatten_inputs "${inputs}")"

  check_input_paths_and_locations "${flattened_inputs}" "${ICA_ACCESS_TOKEN}" "${ICA_BASE_URL}"
}

check_engine_parameters(){
  : '
  Check the engine parameters
  '
  local engine_parameters="$1"

  echo_stderr "$(jq 'keys | length' <<< "${engine_parameters}")"

  # Check if inputs are null
  if [[ -z "${engine_parameters}" || "${engine_parameters}" == "null" || "$(jq 'keys | length' <<< "${engine_parameters}")" == "0" ]]; then
    echo_stderr "Could not find any engine parameters, under 'engineParameters'"
    echo_stderr "For future runs, I would recommend setting outputDirectory and workDirectory."
  fi

  return 0
}

check_input_paths_and_locations(){
  : '
  Iterate through inputs, make sure each gds path exists in this context
  '
  local flattened_inputs="$1"
  local ica_access_token="$2"
  local ica_base_url="$3"
  local all_there=0  # Is everything present?

  # Iterate through key val pairs
  # Like tumor_fastq_list_rows.0.read_1.location=gds://...
  while read -r input_key_val_pair; do
     # Split into keys and values
     input_key="$(cut -d'=' -f1 <<< "${input_key_val_pair}")"
     input_value="$(cut -d'=' -f2 <<< "${input_key_val_pair}")"

     # Stripped input key
     input_key_stripped="$(strip_last_period "${input_key}")"

     # Check if the input-key ends in .path or .location
     if [[ "${input_key}" =~ .*\.path || "${input_key}" =~ .*\.location ]]; then
       # Get class type
       class_type="$(get_class_type "${input_key_stripped}" "${flattened_inputs}")"
       if [[ "${class_type}" == "gds_directory" ]]; then
         echo_stderr "Input '${input_key}' is a gds directory at '${input_value}', checking it's present"
         if ! check_folder_exists "${input_key_stripped}" "${input_value}" "${ica_access_token}" "${ica_base_url}"; then
           echo_stderr "Error! Could not find gds directory '${input_value}'"
           all_there=1
         else
            echo_stderr "gds directory '${input_value}' exists!"
         fi
       elif [[ "${class_type}" == "gds_file" ]]; then
        echo_stderr "Input '${input_key}' is a gds file at '${input_value}' checking it's present"
         if ! check_file_exists "${input_key_stripped}" "${input_value}" "${ica_access_token}" "${ica_base_url}"; then
           echo_stderr "Error! Could not find gds file '${input_value}'"
           all_there=1
         else
            echo_stderr "gds file '${input_value}' exists!"
         fi
       fi
     fi
  done <<< "${flattened_inputs}"

  if [[ "${all_there}" == 1 ]]; then
    return 1
  else
    return 0
  fi
}

print_help(){
  echo "
  Usage ica-check-cwl-inputs (--input-json <json-file>)

  Description:
    Validates your input json and makes sure all inputs of type File and Directory are readable on GDS

  Options:
    -i / --input-json: The input json file you wish to analyse

  Requirements:
    * curl
    * jq
    * python3
    * sed (gnutls)

  Environment variables:
    * ICA_ACCESS_TOKEN
    * ICA_BASE_URL
  "
}

######
# ARGS
######

# Get args from the command line
input_json=""

# Get args from command line
while [ $# -gt 0 ]; do
  case "$1" in
    -i | --input-json)
      input_json="$2"
      shift 1
      ;;
    -h | --help)
      print_help
      exit 0
      ;;
  esac
  shift 1
done

# Make sure input_json is defined and is a file
if [[ -z "${input_json}" ]]; then
  echo_stderr "Please specify --input-json"
  print_help
  exit 1
elif [[ ! -f "${input_json}" ]]; then
  echo_stderr "--input-json specified as ${input_json} but could not find file."
  print_help
  exit 1
fi

# Check json integrity
if ! jq type "${input_json}" >/dev/null 2>&1; then
  echo_stderr "Could not confirm input json '${input_json}' was a valid json"
  print_help
  exit 1
fi

# Check ICA_BASE_URL env var is set
if [[ -z "${ICA_BASE_URL-}" ]]; then
  echo_stderr "Please set ICA_BASE_URL"
  print_help
  exit 1
fi

# Check we're in a project context
if [[ -z "${ICA_ACCESS_TOKEN-}" ]]; then
  echo_stderr "Please specify ICA_ACCESS_TOKEN"
  print_help
  exit 1
fi

# Check name attribute
echo_stderr "Checking name attribute is present"
name_value="$(jq --raw-output '.name' "${input_json}")"
if ! check_name_value "${name_value}"; then
  exit 1
fi
echo_stderr "Name value is good"

echo_stderr "Checking input is present"
input_value="$(jq --raw-output '.input' "${input_json}")"
if ! check_input_value "${input_value}"; then
  exit 1
fi
echo_stderr "Input is good"

echo_stderr "Checking engineParameters"
engine_parameters_value="$(jq --raw-output '.engineParameters' "${input_json}")"
if ! check_engine_parameters "${engine_parameters_value}"; then
  exit 1
fi
echo_stderr "engineParameters is good"